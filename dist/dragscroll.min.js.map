{"version":3,"file":"dragscroll.min.js","sources":["../src/DragScroll.ts"],"sourcesContent":["import EventEmitter from \"@scena/event-emitter\";\nimport { isFunction, isString, now } from \"@daybrush/utils\";\nimport { CheckScrollOptions, DragScrollEvents, DragScrollOptions, Rect } from \"./types\";\n\nfunction getDefaultScrollPosition(e: { container: HTMLElement, direction: number[] }) {\n    let container = e.container;\n\n    if (container === document.body) {\n        return [\n            container.scrollLeft || document.documentElement.scrollLeft,\n            container.scrollTop || document.documentElement.scrollTop,\n        ];\n    }\n    return [\n        container.scrollLeft,\n        container.scrollTop,\n    ];\n}\n\nfunction checkDefaultScrollEvent(container: HTMLElement | Window, callback: () => void) {\n    container.addEventListener(\"scroll\", callback);\n\n    return () => {\n        container.removeEventListener(\"scroll\", callback);\n    }\n}\n\nfunction getContainerElement(container: DragScrollOptions[\"container\"]): HTMLElement {\n    if (!container) {\n        return null;\n    } else if (isString(container)) {\n        return document.querySelector<HTMLElement>(container);\n    } if (isFunction(container)) {\n        return container();\n    } else if (container instanceof Element) {\n        return container;\n    } else if (\"current\" in container) {\n        return container.current;\n    } else if (\"value\" in container) {\n        return container.value;\n    }\n}\n\n/**\n * @sort 1\n */\nclass DragScroll extends EventEmitter<DragScrollEvents> {\n    private _startRect: Rect | null = null;\n    private _startPos: number[] = [];\n    private _prevTime: number = 0;\n    private _timer: number = 0;\n    private _prevScrollPos: number[] = [0, 0];\n    private _isWait = false;\n    private _flag = false;\n    private _currentOptions: DragScrollOptions | null = null;\n    private _lock = false;\n    private _unregister: (() => void) | null = null;\n    /**\n     */\n    public dragStart(e: any, options: DragScrollOptions) {\n        const container = getContainerElement(options.container);\n\n        if (!container) {\n            this._flag = false;\n            return;\n        }\n        let top = 0;\n        let left = 0;\n        let width = 0;\n        let height = 0;\n\n        if (container === document.body) {\n            width = window.innerWidth;\n            height = window.innerHeight;\n        } else {\n            const rect = container.getBoundingClientRect();\n\n            top = rect.top;\n            left = rect.left;\n            width = rect.width;\n            height = rect.height;\n        }\n\n        this._flag = true;\n        this._startPos = [e.clientX, e.clientY];\n        this._startRect = { top, left, width, height };\n        this._prevScrollPos = this._getScrollPosition([0, 0], options);\n        this._currentOptions = options;\n        this._registerScrollEvent(options);\n    }\n    public drag(e: any, options: DragScrollOptions) {\n        clearTimeout(this._timer);\n        if (!this._flag) {\n            return;\n        }\n        const {\n            clientX,\n            clientY,\n        } = e;\n        const {\n            threshold = 0,\n        } = options;\n        const {\n            _startRect,\n            _startPos,\n        } = this;\n\n\n        this._currentOptions = options;\n        const direction = [0, 0];\n\n        if (_startRect.top > clientY - threshold) {\n            if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n                direction[1] = -1;\n            }\n        } else if (_startRect.top + _startRect.height < clientY + threshold) {\n            if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {\n                direction[1] = 1;\n            }\n        }\n        if (_startRect.left > clientX - threshold) {\n            if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n                direction[0] = -1;\n            }\n        } else if (_startRect.left + _startRect.width < clientX + threshold) {\n            if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {\n                direction[0] = 1;\n            }\n        }\n\n        if (!direction[0] && !direction[1]) {\n            return false;\n        }\n        return this._continueDrag({\n            ...options,\n            direction,\n            inputEvent: e,\n            isDrag: true,\n        });\n    }\n    /**\n     */\n    public checkScroll(options: CheckScrollOptions) {\n        if (this._isWait) {\n            return false;\n        }\n        const {\n            prevScrollPos = this._prevScrollPos,\n            direction,\n            throttleTime = 0,\n            inputEvent,\n            isDrag,\n        } = options;\n        const nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n        const offsetX = nextScrollPos[0] - prevScrollPos[0];\n        const offsetY = nextScrollPos[1] - prevScrollPos[1];\n\n        const nextDirection = direction || [\n            offsetX ? Math.abs(offsetX) / offsetX : 0,\n            offsetY ? Math.abs(offsetY) / offsetY : 0,\n        ];\n        this._prevScrollPos = nextScrollPos;\n        this._lock = false;\n\n        if (!offsetX && !offsetY) {\n            return false;\n        }\n        /**\n         * @event DragScroll#move\n         */\n        this.emit(\"move\", {\n            offsetX: nextDirection[0] ? offsetX : 0,\n            offsetY: nextDirection[1] ? offsetY : 0,\n            inputEvent,\n        });\n\n        if (throttleTime && isDrag) {\n            clearTimeout(this._timer);\n            this._timer = window.setTimeout(() => {\n                this._continueDrag(options);\n            }, throttleTime);\n        }\n        return true;\n    }\n    /**\n     *\n     */\n    public dragEnd() {\n        this._flag = false;\n        this._lock = false;\n        clearTimeout(this._timer);\n        this._unregisterScrollEvent();\n    }\n    private _getScrollPosition(direction: number[], options: DragScrollOptions) {\n        const {\n            container,\n            getScrollPosition = getDefaultScrollPosition,\n        } = options;\n        return getScrollPosition({ container: getContainerElement(container), direction });\n    }\n    private _continueDrag(options: CheckScrollOptions) {\n        const {\n            container,\n            direction,\n            throttleTime,\n            useScroll,\n            isDrag,\n            inputEvent,\n        } = options;\n\n        if (!this._flag || (isDrag && this._isWait)) {\n            return;\n        }\n        const nowTime = now();\n        const distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n\n        if (distTime > 0) {\n            clearTimeout(this._timer);\n            this._timer = window.setTimeout(() => {\n                this._continueDrag(options);\n            }, distTime);\n\n            return false;\n        }\n        this._prevTime = nowTime;\n        const prevScrollPos = this._getScrollPosition(direction, options);\n\n        this._prevScrollPos = prevScrollPos;\n\n        if (isDrag) {\n            this._isWait = true;\n        }\n\n        // unregister native scroll event\n        if (!useScroll) {\n            this._lock = true;\n        }\n        const param = {\n            container: getContainerElement(container),\n            direction,\n            inputEvent,\n        };\n        options.requestScroll?.(param);\n        /**\n         * @event DragScroll#scroll\n         */\n        this.emit(\"scroll\", param);\n\n        this._isWait = false;\n        return useScroll || this.checkScroll({\n            ...options,\n            prevScrollPos,\n            direction,\n            inputEvent,\n        });\n    }\n\n    private _registerScrollEvent(options: DragScrollOptions) {\n        this._unregisterScrollEvent();\n        const checkScrollEvent = options.checkScrollEvent;\n\n        if (!checkScrollEvent) {\n            return;\n        }\n        const callback = checkScrollEvent === true ? checkDefaultScrollEvent : checkScrollEvent;\n        const container = getContainerElement(options.container);\n\n        if (checkScrollEvent === true && (container === document.body || container === document.documentElement)) {\n            this._unregister = checkDefaultScrollEvent(window, this._onScroll);\n        } else {\n            this._unregister = callback(container, this._onScroll);\n        }\n    }\n    private _unregisterScrollEvent() {\n        this._unregister?.();\n        this._unregister = null;\n    }\n\n    private _onScroll = () => {\n        const options = this._currentOptions;\n        if (this._lock || !options) {\n            return;\n        }\n\n        this.emit(\"scrollDrag\", {\n            next: (inputEvent: any) => {\n                this.checkScroll({\n                    container: options.container,\n                    inputEvent,\n                });\n            },\n        });\n    };\n}\n\nexport default DragScroll;\n"],"names":["getDefaultScrollPosition","e","container","document","body","scrollLeft","documentElement","scrollTop","checkDefaultScrollEvent","callback","addEventListener","removeEventListener","getContainerElement","querySelector","Element","current","value","_this","options","_currentOptions","_lock","emit","next","inputEvent","checkScroll","__proto","top","left","width","height","window","innerWidth","innerHeight","rect","getBoundingClientRect","this","_flag","_startPos","clientX","clientY","_startRect","_prevScrollPos","_getScrollPosition","_registerScrollEvent","threshold","direction","clearTimeout","_timer","_a","_continueDrag","isDrag","throttleTime","nextScrollPos","offsetX","offsetY","nextDirection","_isWait","prevScrollPos","_b","Math","abs","setTimeout","_unregisterScrollEvent","useScroll","nowTime","distTime","max","_prevTime","param","requestScroll","checkScrollEvent","_unregister","_onScroll"],"mappings":"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"}